import unittest
import os
import sys
from typing import Dict, Optional

srcPath = os.path.dirname(os.path.abspath(__file__)).rsplit('tests',1)[0] + 'src'
sys.path.insert(0,srcPath)

from pulses.Parameter import Parameter
from pulses.Sequencer import SequencingElement, Sequencer
from pulses.Instructions import InstructionBlock, InstructionPointer, Trigger, WaveformTable, Waveform, CJMPInstruction, GOTOInstruction, STOPInstruction
from pulses.Condition import HardwareCondition, SoftwareCondition, ConditionEvaluationException


class DummySequencingElement(SequencingElement):
    
    def build_sequence(self, sequencer: Sequencer, time_parameters: Dict[str, Parameter], voltage_parameters: Dict[str, Parameter], instruction_block: InstructionBlock) -> None:
        raise NotImplementedError()
        
    def requires_stop(self, time_parameters: Dict[str, Parameter], voltage_parameters: Dict[str, Parameter]) -> bool:
        raise NotImplementedError()
    
    def __eq__(self, other) -> bool:
        return self is other
    
    def __ne__(self, other) -> bool:
        return not self == other
    
    def __hash__(self) -> int:
        return hash(id(self))
    
class DummySequencer(Sequencer):
    
    def __init__(self) -> None:
        super().__init__(None)
        self.sequencing_stacks = {} #type: Dict[InstructionBlock, List[StackElement]]
        
    def push(self, sequencing_element: SequencingElement, parameters: Dict[str, Parameter], target_block: InstructionBlock = None) -> None:
        if target_block is None:
            target_block = self.__main_block
            
        if not target_block in self.sequencing_stacks:
            self.sequencing_stacks[target_block] = []
            
        self.sequencing_stacks[target_block].append((sequencing_element, parameters))
        
    def build(self) -> InstructionBlock:
        raise NotImplementedError()
        
    def has_finished(self):
        raise NotImplementedError()
        
    def register_waveform(self, waveform_table: WaveformTable) -> Waveform:
        raise NotImplementedError()
    
class DummyInstructionBlock(InstructionBlock):
    
    def __init__(self, outerBlock: InstructionBlock = None) -> None:
        super().__init__(outerBlock)
        self.embedded_blocks = [] # type: Collection[InstructionBlock]
        
    def create_embedded_block(self) -> InstructionBlock:
        block = InstructionBlock(self)
        self.embedded_blocks.append(block)
        return block

class HardwareConditionTest(unittest.TestCase):
    
    def test_build_sequence_loop(self) -> None:        
        sequencer = DummySequencer()
        block = DummyInstructionBlock()
        
        delegator = DummySequencingElement()
        body = DummySequencingElement()
        
        trigger = Trigger()
        condition = HardwareCondition(trigger)
        condition.build_sequence_loop(delegator, body, sequencer, [], block)
        
        self.assertEqual(1, len(block.embedded_blocks))
        body_block = block.embedded_blocks[0]
        
        self.assertEqual([CJMPInstruction(trigger, body_block, 0)], block.instructions, "The expected conditional jump was not generated by HardwareConditon.")
        self.assertEqual(InstructionPointer(block, 0), body_block.return_ip, "The return address of the loop body block was set wrongly by HardwareCondition.")
        self.assertEqual({body_block: [(body, [])]}, sequencer.sequencing_stacks, "HardwareCondition did not correctly push the body element to the stack")
        
    
    def test_build_sequence_branch(self) -> None:
        sequencer = DummySequencer()
        block = DummyInstructionBlock()
        
        delegator = DummySequencingElement()
        if_branch = DummySequencingElement()
        else_branch = DummySequencingElement()
        
        trigger = Trigger()
        condition = HardwareCondition(trigger)
        condition.build_sequence_branch(delegator, if_branch, else_branch, sequencer, [], block)
        
        self.assertEqual(2, len(block.embedded_blocks))
        if_block = block.embedded_blocks[0]
        else_block = block.embedded_blocks[1]
        
        self.assertEqual([CJMPInstruction(trigger, if_block, 0), GOTOInstruction(else_block, 0)], block.instructions, "The expected jump instruction were not generated by HardwareConditon.")
        self.assertEqual(InstructionPointer(block, 2), if_block.return_ip, "The return address of the if branch block was set wrongly by HardwareConditon.")
        self.assertEqual(InstructionPointer(block, 2), else_block.return_ip, "The return address of the else branch block was set wrongly by HardwareConditon.")
        self.assertEqual({if_block: [(if_branch, [])], else_block: [(else_branch, [])]}, sequencer.sequencing_stacks, "HardwareCondition did not correctly push the branch elements to the stack")
        

class IterationCallbackDummy:
    
    def __init__(self, callback_return: Optional[bool]) -> None:
        super().__init__()
        self.callback_return = callback_return
        self.loop_iteration = 0
    
    def callback(self, loop_iteration: int) -> Optional[bool]:
        self.loop_iteration = loop_iteration
        return self.callback_return
        

class SoftwareConditionTest(unittest.TestCase):
    
    def test_build_cannot_evaluate(self) -> None:
        sequencer = DummySequencer()
        block = DummyInstructionBlock()
        
        delegator = DummySequencingElement()
        body = DummySequencingElement()
        
        condition = SoftwareCondition(lambda loop_iteration: None)
        
        self.assertTrue(condition.requires_stop())
        self.assertRaises(ConditionEvaluationException, condition.build_sequence_loop, delegator, body, sequencer, [], block)
        self.assertRaises(ConditionEvaluationException, condition.build_sequence_branch, delegator, body, body, sequencer, [], block)
    
    def test_build_sequence_loop_true(self) -> None:
        sequencer = DummySequencer()
        block = DummyInstructionBlock()
        
        delegator = DummySequencingElement()
        body = DummySequencingElement()
        callback = IterationCallbackDummy(True)
        
        condition = SoftwareCondition(lambda loop_iteration: callback.callback(loop_iteration))
        condition.build_sequence_loop(delegator, body, sequencer, [], block)
        
        self.assertEqual(0, callback.loop_iteration)
        self.assertFalse(block.instructions)
        self.assertEqual({block: [(delegator, []), (body, [])]}, sequencer.sequencing_stacks)
        
        condition.build_sequence_loop(delegator, body, sequencer, [], block)
        self.assertEqual(1, callback.loop_iteration)
        
    def test_build_sequence_loop_false(self):
        sequencer = DummySequencer()
        block = DummyInstructionBlock()
        
        delegator = DummySequencingElement()
        body = DummySequencingElement()
        callback = IterationCallbackDummy(False)
        
        condition = SoftwareCondition(lambda loop_iteration: callback.callback(loop_iteration))
        condition.build_sequence_loop(delegator, body, sequencer, [],  block)
        
        self.assertEqual(0, callback.loop_iteration)
        self.assertFalse(block.instructions)
        self.assertFalse(sequencer.sequencing_stacks)
        
        condition.build_sequence_loop(delegator, body, sequencer, [], block)
        self.assertEqual(0, callback.loop_iteration)
        
    def test_build_sequence_branch_true(self):
        sequencer = DummySequencer()
        block = DummyInstructionBlock()
        
        delegator = DummySequencingElement()
        if_branch = DummySequencingElement()
        else_branch = DummySequencingElement()
        callback = IterationCallbackDummy(True)
        
        condition = SoftwareCondition(lambda loop_iteration: callback.callback(loop_iteration))
        condition.build_sequence_branch(delegator, if_branch, else_branch, sequencer, [], block)
        
        self.assertEqual(0, callback.loop_iteration)
        self.assertFalse(block.instructions)
        self.assertEqual({block: [(if_branch, [])]}, sequencer.sequencing_stacks)
        
        condition.build_sequence_branch(delegator, if_branch, else_branch, sequencer, [], block)
        self.assertEqual(0, callback.loop_iteration)
        
        
    def test_build_sequence_branch_false(self):
        sequencer = DummySequencer()
        block = DummyInstructionBlock()
        
        delegator = DummySequencingElement()
        if_branch = DummySequencingElement()
        else_branch = DummySequencingElement()
        callback = IterationCallbackDummy(False)
        
        condition = SoftwareCondition(lambda loop_iteration: callback.callback(loop_iteration))
        condition.build_sequence_branch(delegator, if_branch, else_branch, sequencer, [], block)
        
        self.assertEqual(0, callback.loop_iteration)
        self.assertFalse(block.instructions)
        self.assertEqual({block: [(else_branch, [],)]}, sequencer.sequencing_stacks)
        
        condition.build_sequence_branch(delegator, if_branch, else_branch, sequencer, [], block)
        self.assertEqual(0, callback.loop_iteration)

if __name__ == "__main__":
    unittest.main(verbosity=2)