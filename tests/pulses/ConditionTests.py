import unittest
import os
import sys
from typing import Dict

srcPath = os.path.dirname(os.path.abspath(__file__)).rsplit('tests',1)[0] + 'src'
sys.path.insert(0,srcPath)

from pulses.Parameter import Parameter
from pulses.Sequencer import SequencingElement, Sequencer
from pulses.Instructions import InstructionBlock, InstructionPointer, Trigger, WaveformTable, Waveform, CJMPInstruction, GOTOInstruction, STOPInstruction
from pulses.Condition import HardwareCondition, SoftwareCondition


class DummySequencingElement(SequencingElement):
    
    def build_sequence(self, sequencer: Sequencer, time_parameters: Dict[str, Parameter], voltage_parameters: Dict[str, Parameter], instruction_block: InstructionBlock) -> None:
        raise NotImplementedError()
        
    def requires_stop(self, time_parameters: Dict[str, Parameter], voltage_parameters: Dict[str, Parameter]) -> bool:
        raise NotImplementedError()
    
    def __eq__(self, other) -> bool:
        return self is other
    
    def __ne__(self, other) -> bool:
        return not self == other
    
    def __hash__(self) -> int:
        return hash(id(self))
    
class DummySequencer(Sequencer):
    
    def __init__(self):
        super().__init__(None)
        self.sequencing_stack = [] #type: List[StackElement]
        
    def push(self, sequencing_element: SequencingElement, time_parameters: Dict[str, Parameter], voltage_parameters: Dict[str, Parameter], target_block: InstructionBlock = None) -> None:
        self.sequencing_stack.append((sequencing_element, time_parameters, voltage_parameters, target_block))
        
    def build(self) -> InstructionBlock:
        raise NotImplementedError()
        
    def has_finished(self):
        raise NotImplementedError()
        
    def register_waveform(self, waveform_table: WaveformTable) -> Waveform:
        raise NotImplementedError()
    
class DummyInstructionBlock(InstructionBlock):
    
    def __init__(self, outerBlock: 'InstructionBlock' = None):
        super().__init__(outerBlock)
        self.embedded_blocks = [] # type: Collection[InstructionBlock]
        
    def create_embedded_block(self) -> 'InstructionBlock':
        block = InstructionBlock(self)
        self.embedded_blocks.append(block)
        return block

class HardwareConditionTest(unittest.TestCase):
    
    def test_build_sequence_loop(self):        
        sequencer = DummySequencer()
        block = DummyInstructionBlock()
        
        delegator = DummySequencingElement()
        body = DummySequencingElement()
        
        trigger = Trigger()
        condition = HardwareCondition(trigger)
        condition.build_sequence_loop(delegator, body, sequencer, [], [], block)
        
        self.assertEqual(1, len(block.embedded_blocks))
        body_block = block.embedded_blocks[0]
        
        self.assertEqual([CJMPInstruction(trigger, body_block, 0)], block.instructions, "The expected conditional jump was not generated by HardwareConditon.")
        self.assertEqual(InstructionPointer(block, 0), body_block.return_ip, "The return address of the loop body block was set wrongly by HardwareCondition.")
        self.assertEqual([(body, [], [], body_block)], sequencer.sequencing_stack, "HardwareCondition did not correctly push the body element to the stack")
        
    
    def test_build_sequence_branch(self):
        sequencer = DummySequencer()
        block = DummyInstructionBlock()
        
        delegator = DummySequencingElement()
        if_branch = DummySequencingElement()
        else_branch = DummySequencingElement()
        
        trigger = Trigger()
        condition = HardwareCondition(trigger)
        condition.build_sequence_branch(delegator, if_branch, else_branch, sequencer, [], [], block)
        
        self.assertEqual(2, len(block.embedded_blocks))
        if_block = block.embedded_blocks[0]
        else_block = block.embedded_blocks[1]
        
        self.assertEqual([CJMPInstruction(trigger, if_block, 0), GOTOInstruction(else_block, 0)], block.instructions, "The expected jump instruction were not generated by HardwareConditon.")
        self.assertEqual(InstructionPointer(block, 2), if_block.return_ip, "The return address of the if branch block was set wrongly by HardwareConditon.")
        self.assertEqual(InstructionPointer(block, 2), else_block.return_ip, "The return address of the else branch block was set wrongly by HardwareConditon.")
        self.assertEqual([(if_branch, [], [], if_block), (else_branch, [], [], else_block)], sequencer.sequencing_stack, "HardwareCondition did not correctly push the branch elements to the stack")
        


class SoftwareConditionTest(unittest.TestCase):
    
    def test_build_sequence_loop_cannot_evaluate(self):
        sequencer = DummySequencer()
        block = DummyInstructionBlock()
        
        delegator = DummySequencingElement()
        body = DummySequencingElement()
        
        condition = SoftwareCondition(lambda: None)
        condition.build_sequence_loop(delegator, body, sequencer, [], [], block)
        
        self.assertEqual([STOPInstruction()], block.instructions)
        self.assertEqual([(delegator, [], [], block)], sequencer.sequencing_stack)
    
    def test_build_sequence_loop_true(self):
        sequencer = DummySequencer()
        block = DummyInstructionBlock()
        
        delegator = DummySequencingElement()
        body = DummySequencingElement()
        
        condition = SoftwareCondition(lambda: True)
        condition.build_sequence_loop(delegator, body, sequencer, [], [], block)
        
        self.assertFalse(block.instructions)
        self.assertEqual([(delegator, [], [], block), (body, [], [], block)], sequencer.sequencing_stack)
        
    def test_build_sequence_loop_false(self):
        sequencer = DummySequencer()
        block = DummyInstructionBlock()
        
        delegator = DummySequencingElement()
        body = DummySequencingElement()
        
        condition = SoftwareCondition(lambda: False)
        condition.build_sequence_loop(delegator, body, sequencer, [], [], block)
        
        self.assertFalse(block.instructions)
        self.assertFalse(sequencer.sequencing_stack)
    
    def test_build_sequence_branch_cannot_evaluate(self):
        sequencer = DummySequencer()
        block = DummyInstructionBlock()
        
        delegator = DummySequencingElement()
        if_branch = DummySequencingElement()
        else_branch = DummySequencingElement()
        
        condition = SoftwareCondition(lambda: None)
        condition.build_sequence_branch(delegator, if_branch, else_branch, sequencer, [], [], block)
        
        self.assertEqual([STOPInstruction()], block.instructions)
        self.assertEqual([(delegator, [], [], block)], sequencer.sequencing_stack)
        
    def test_build_sequence_branch_true(self):
        sequencer = DummySequencer()
        block = DummyInstructionBlock()
        
        delegator = DummySequencingElement()
        if_branch = DummySequencingElement()
        else_branch = DummySequencingElement()
        
        condition = SoftwareCondition(lambda: True)
        condition.build_sequence_branch(delegator, if_branch, else_branch, sequencer, [], [], block)
        
        self.assertFalse(block.instructions)
        self.assertEqual([(if_branch, [], [], block)], sequencer.sequencing_stack)
        
    def test_build_sequence_branch_false(self):
        sequencer = DummySequencer()
        block = DummyInstructionBlock()
        
        delegator = DummySequencingElement()
        if_branch = DummySequencingElement()
        else_branch = DummySequencingElement()
        
        condition = SoftwareCondition(lambda: False)
        condition.build_sequence_branch(delegator, if_branch, else_branch, sequencer, [], [], block)
        
        self.assertFalse(block.instructions)
        self.assertEqual([(else_branch, [], [], block)], sequencer.sequencing_stack)
        

if __name__ == "__main__":
    unittest.main(verbosity=2)