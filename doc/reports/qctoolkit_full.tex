\documentclass[a4paper,12pt]{article}
\usepackage{fancyhdr, graphicx}
\usepackage[utf8]{inputenc}
\usepackage[top=2.5cm,left=3cm,right=3cm,bottom=3cm]{geometry}
\usepackage{hyperref}
% \usepackage[headsepline,footsepline]{scrpage2}

\renewcommand{\headrulewidth}{0.4pt} %obere Trennlinie
\renewcommand{\footrulewidth}{0.4pt} %untere Trennlinie
\pagestyle{fancy}
\fancyhf{}
\rhead{\raisebox{1.2\baselineskip}{
\includegraphics[height=1cm]{pictures/qutech}}}
\lhead{\raisebox{1.2\baselineskip}{
\includegraphics[height=0.75cm]{pictures/se}}}
\chead{\leftmark}
\cfoot{\thepage}


\title{\vspace*{2cm}{\huge \textbf{QC-Toolkit}}\\ {\large Version 0.3 - DRAFT}\vspace*{2.5cm}}
\author{RWTH Aachen University}
% \date{2015-03-19}
\begin{document}
\maketitle

\begin{abstract}
This document describes the current status of the requirement analysis and the implementation progress of the QC-Toolkit project. This project consists in the restructuring of the pulsecontrol (special measure) project of Prof.~Dr.~Hendrik~Bluhm. 
In short, the QC-Toolkit should increase the modularity and flexibility of pulsecontrol.
\end{abstract}

\thispagestyle{fancy}
\vfill

{\footnotesize \textbf{Every effort has been made to ensure that all statements and information contained herein are accurate, however the QC-Toolkit crew accept no liability for any error or omission in the same.}}
\newpage

\tableofcontents

\newpage
\section*{Involved People}

\underline{\textbf{The Bluhm Group (Physics)}}
\begin{description} \itemsep-0.5pt
 \item[Prof.~Dr.~Hendrik Bluhm] Project initiator and supervisor.
 \item[Patrick Bethke] PhD-Student
 \item[Pascal Cerfontaine] PhD-Student
 \item[Tim Botzem] PhD-Student
 \item[Simon Humpohl] Scientific assistant
\end{description}

\noindent
\underline{\textbf{The Rumpe Group (Computer Science)}}
\begin{description} \itemsep-0.5pt
 \item[Prof.~Dr.~Bernhardt Rumpe] Project initiator and supervisor.
 \item[Deni Raco] Student assistant supervisor
 \item[Lukas Prediger] Scientific assistant
 \item[Jerome Bergmann] Scientific assistant
 
\end{description}


%\section{Theoretical background}

\section{Introduction}
Experiments in quantum mechanics involve the manipulation of a quantum object and some measurement of its behavior. In the context of the experiments performed by the physicists of the Bluhm Group this manipulation is performed via sequences of voltages (waveforms) applied to electrodes in the vicinity of the quantum object (e.g. a dual-electron qubit). Such a waveform is called a pulse when used to manipulate a quantum object. The measurement also results in a waveform induced by changes in the electromagnetic field of the quantum object depending on its state. Multiple concurrent pulses may be used to manipulate the quantum objects.\par
To execute an experiment, pulses have to be defined as well as corresponding measurement windows. As one goal is to find optimal pulses for certain quantum state changes, pulses have to be refined in an iterative process, where a starting pulse is found by simulation and then refined based on experimental data. Some pulses may be constructed as a sequence of other, more basic pulses. Ultimately, pulses that implement quantum gates may be found by composing elementary state manipulation pulses.\par
Pulses are generated by so called \texttt{Arbitrary Waveform Generator}s (\texttt{AWG}s). These are hardware devices that receive a discrete digital byte array representation of a waveform where each byte represents the amplitude of the pulse at the corresponding clock tick and generate a continuous analog waveform. Measurement data is captured by \texttt{Data Acquisition Card}s (\texttt{DAC}s) which essentially do the same in reverse.\par
A software system that allows the construction of pulses and the measuring and evaluation of experimental data independent of the hardware and its wiring/setup is required for the execution of experiments. The software currently used by the Bluhm Group for this purposes as well as its shortcomings is described briefly in Section \ref{sec:CurrentState}. The QC-Toolkit project is intended to produce a more general framework which enables quantum mechanical experiments. Later on, it shall be extended to enable modeling and possibly execution and simulation of quantum circuits. A detailed list of requirements is provided in Section \ref{sec:Requirements} followed by a prototypical software design and implementation proposition in Section \ref{sec:Proposition}.\par
\texttt{Disclaimer:} Please note that the above description is only intended to provide a broad overview of the physical background for the software. It may thus be incorrect in some details but should convey the relevant information. For a more accurate and detailed description of the physics involved and the actual experiment performed by the Bluhm Group, please refer to the corresponding literature.

\section{Roadmap}
\subsection{Meetings}
\begin{itemize} \itemsep-0.5pt
 \item \texttt{26.01.2015}: \textbf{Kickoff Meeting}: Explanation of the project, declare first steps of the Rumpe-Group: Work with Simon Humpohl on \texttt{pulsecontrol} to get a deeper introduction into the system. After one to two month, the requirements analysis started.
 \item \texttt{24.04.2015}: \textbf{Second Meeting}: Presentation of the research results and a first draft for the structure of the qc-toolkit. The feedbacks were generally positive but clarification and more implementation details requested.
 \item \texttt{19.05.2015}: \textbf{Third Meeting}: Reviewed draft of the first implementation. More strict separation of the individual features. Approval to start implementation. Also discussion about serializing techniques for pulses.
 \item \texttt{13.07.2015}: \textbf{First sprint Meeting}: Presentation of the result of the first sprint phase: The core is partially written and presentation of the first hardware interface instruction set.
 \item \texttt{next meeting}: probably end of august
\end{itemize}

\subsection{Tasks}
\begin{itemize} \itemsep-0.5pt
 \item \texttt{high priority}: In general, the highest priority is to reach a runnable system which has at least the same functionality as \texttt{pulsecontrol} to allow a transition to qc-toolkit for the physicists.
 \begin{itemize} \itemsep-0.5pt
  \item Core implemenation
  \item Generic hardware interface design
  \item Serializing of pulses
 \end{itemize}
  \item \texttt{medium priority}: In general, these are nice-to-have features, which doesn't change the general behavior of qc-toolkit, but make the work with the toolkit more comfortable and easier.
 \begin{itemize} \itemsep-0.5pt
  \item Plotting
  \item First driver
  \item Logging levels for Pulses
 \end{itemize}
 \item \texttt{low priority}: These features are targeting future hardware or features which can only be introduced when core is finished.
 \begin{itemize} \itemsep-0.5pt
  \item Feedback loops
  \item Function calls in the hardware interface
 \end{itemize}
\end{itemize}

\section{Special-Measure and PulseControl: The Current State}
\label{sec:CurrentState}
The Bluhm Group currently uses the special-measure project\footnote{\href{https://github.com/qutech/special-measure}{github.com/qutech/special-measure}} for data acquisition and evaluation and the self-implemented special-measure.pulsecontrol\footnote{\href{https://github.com/qutech/special-measure.pulsecontrol}{github.com/qutech/special-measure.pulsecontrol}} for pulse definition and executing.

Special-measure is a general purpose data acquisition package for (table top scale) physics experiments. Out of that project, the Bluhm Group created pulsecontrol, a package for defining and tracking AWG pulses for quantum information experiments. It communicates with special-measure in a few places but is largely independent. Both projects are written in the MATLAB script language in a largely imperative manner using global variables to store state information.

As the development of pulsecontrol took place over several years, it is now a feature rich toolkit. Currently, the project has reached a state where it is hard to understand, modify, extend and repair with dependencies being reaching through the entire code base.
To address these issues, the QC-Toolkit Project has been initiated, aiming for an object oriented reimplementation of pulsecontrol functionality and subsequently adding more features and higher abstraction.

Furthermore, in the current state the user has to define pulses and set up the software using its MATLAB API for each experiment. It may be easier if the user could just specify pulses and hardware setup entirely as data (files) without ever touching any programming language and that the software then derives its internal configuration and pulse representation from this automatically.

\subsection{Introductional Work: The Driver Interface}
Initially, the pulsecontrol toolkit featured only single AWG support. It was not possible to employ multiple AWGs or even AWGs that exhibited different interfaces (i.e., ones from different manufacturers). During the writing of this document, the pulsecontrol toolkit has been actively expanded for multi AWG support which is critical for upcoming experiments. The basic concept allows to map the channels of a virtual AWG onto hardware channels provided by several ``real'' AWGs.

Additionally, a data acquisition driver has been implemented which allows direct filtering and processing of relevant data from the incoming measurement waveforms.

There is a high likeliness that the results of these two current efforts can be directly included in the QC-Toolkit or at least adapted with only minor changes.

%\subsection{The Pulse Representation in Quantum Mechanics}
%\paragraph{ todo}: is this correct? for example, the actual implementation of an algorithm may use pulses as a tool but the algorithm itself is independent from pulses. this sections needs some clarification in my opinion.\par
%In quantum mechanics, a pulse can be described on different layers. The last three layers are part of pulsecontrol:
%\begin{description} \itemsep-0.5pt
% \item[Algorithm:] Description in Quantum-Circuit-Form, the most general form, only theoretical
% \item[Optimized Algorithm:] The Algorithm can be adapted to the actual setup with error correction and setup relevant environment variables can be set.
% This layer can also be represented in Quantum-Circuit-Form. One could also make here a separation between the logic gates and the manipulation of environment variables.
% \item[PulseGroup:] The logic gates can be represented as a PulseGroup, which may contain PulseTabs and Pulses.
% \item[PulseTab:] Tabular description of a Pulse. Only major supporting points needed. Between two supporting points, a linear interpolation occurs.
% \item[Pulse:] A table containing in the first row all time points and on the other rows the amplitude for each channel.
%\end{description}

\section{Requirements: The Desired State}
\label{sec:Requirements}
Until now, we were able to formulate the following requirements for the QC-Toolkit.
\begin{itemize} \itemsep-0.5pt
 \item The system should provide different levels of abstraction: It should be possible to operate directly with pulses (to optimize them or to inspect the physical behavior of the quantum hardware) as well as (later on) representing and executing quantum circuits and algorithms without having to deal with corresponding pulse implementation.
  \item The system should support the execution of quantum circuits/algorithms on real qubit hardware as well as some means of simulation (Integration of the qtip project\footnote{\href{http://qutip.org/}{qutip.org}} might be a viable solution for the latter).
  \item The implementation should be object oriented and easy to maintain.
  \item The system should scale to support any number of input and output channels, concurrent pulses and qubits.
\end{itemize}

\paragraph{Pulses}
\textit{Defining pulses is a crucial feature of the software. It is one of the aspects physicists of the Bluhm Group are most exposed to at the moment as pulses are the input to their experiments. Thus, the software should provide means to quickly compose new pulses or easily modify existing ones.}
\begin{itemize} \itemsep-0.5pt
 \item Basic pulses should be defined by a data driven approach, i.e., a pulse is set up by passing a set of time-voltage points (currently called pulse table or pulsetab). The intermediate values of a pulse are then obtained by interpolating these points either linearly or using a user-defined interpolation function.
 \item It should be possible to nest pulses, i.e., construct pulses by reusing and combining already existing ones.
 \item A pulse should be parameterizable (e.g., varying duration, amplitudes, etc.) and accept mathematical functions that define whether/how these parameters are mapped to subpulses to enable to use it as a template to quickly define variations of pulses with the same structure.
 \item The system must be able to generate corresponding waveforms.
 \item Pulses should be defined independently from the hardware setup or the available output channels.
 \item The system should be able to store pulses, pulse templates and possibly pulse template parameters persistently in some kind of database.
 \item Changes to a pulse in the database should reflect to pulses that refer to the affected pulse as a subpulse.
 \item There may be several database scopes: A global scope, which stores only the most commonly used pulses, preferably as templates, project or hardware scopes, storing templates or concrete pulses\footnote{Here, concrete pulses are pulses that are not parameterizable, probably obtained by filling a pulse template with parameters.} that are commonly used in a specific project for a specific hardware setup and maybe even experiment or user scopes, storing pulses relevant only for a specific experimental run or often used by a user.
\end{itemize}
In the discussion of the third meeting, we agreed to use json as language to serialize pulses to.

\paragraph{Experiments} 
\textit{Here, an experiment is understood as a specific sequence of pulses executed for a specific hardware setup and may be part of an overarching project. Experiments involve execution of the pulse sequence and acquiring and processing the experimental data. Further, there is a need to store the data associated with an experiment such as pulses, parameters, setup, results and possibly user comments and documentation.}
\begin{itemize} \itemsep-0.5pt
 \item A concrete pulse used in a certain experiment must be reconstructable, even if the corresponding pulse in some database (if existent) was changed afterwards.
 \item The system should enable (interactive) feedback loops for optimization of pulses, meaning that in a single experimental run, a pulse is executed, then changed according to the obtained measurement result and executed again until a desired state is reached.
 \item The system should, if possible, enable automatic adjustment of parameters in such a feedback loop depending on the measured data according to a provided set of rules (e.g., mathematical mappings).
 \item A snapshot feature for runs should be implemented to allow interrupting and resuming or replaying an experimental run.
 \item The system should provide conditional branching and looping during an experiment, meaning that, e.g., after some initialization pulse the system selects which pulse to execute next based on some external condition.
\end{itemize}

\paragraph{Hardware Abstraction}
\textit{The migration to other setups or devices should be easy and the interface for both as general as possible. Especially the number of channels must be extensible.}\\
Hardware abstraction should
\begin{itemize} \itemsep-0.5pt
 \item specify general interfaces for AWGs and DACs which abstract from a concrete device.
 \item allow for easy and dynamic exchange of the implementation these interfaces (without compilation).
 \item hide the actual hardware setup and only offer access to user-named virtual channels for input and output.
 \item allow the user to specify the hardware setup as data, containing information which concrete AWGs and DACs are involved, how they are configured and how virtual channels map to the hardware.
 \item allow the dynamic adaption of certain DAC settings (e.g., output voltage range, frequency) to react to changes in the physical environment (e.g., heating) during an experiment.
\end{itemize}
After discussion 4, we all agreed that a good starting point will be a translation of the object oriented treelike representation of a pulse into a assembly-like set of instructions.
The approved instructions are:
\begin{itemize} \itemsep-0.5pt
 \item \texttt{exec <waveform>}: execute a single waveform from device memory
 \item \texttt{cjump <condition/trigger> <target>}: perform a conditional jump to a target instruction index
 \item \texttt{goto <target>}: an unconditional jump
 \item \texttt{stop}: stop playback
\end{itemize}
Prof. Bluhm requested additionally some kind of superior function calls supported by some AWGs.

\paragraph{Data Acquisition}
\textit{Acquiring experimental data is equally important as defining pulses. It is the only source of information to access the quantum state to refine pulses or, later on, execute quantum circuits. Since measuring the state is possible only in certain time windows depending on the executed pulse, the continuous input signal has to be filtered and processed by the software.}\\
To acquire measurement data, the system should
\begin{itemize} \itemsep-0.5pt
 \item capture waveforms on input channels (in real-time).
 \item filter out only relevant information from these waveforms according to user-specified masks.
 \item process (accumulate, transform, map,..) the obtained data.
 \item identify to which pulse(s) the captured data belongs (depending on the hardware setup specified by the user).
\end{itemize}

\paragraph{Quantum Circuits}
\textit{Ultimately, the system should provide functionality to execute algorithms on quantum hardware (if possible).}
\begin{itemize} \itemsep-0.5pt
 \item The system should provide means to model (and possibly execute) Quantum Circuits, i.e., Quantum Gates and Qubits.
 \item This model should be independent from underlying implementation (execution on hardware using pulses, simulation, etc.).
\end{itemize}

\paragraph{Code Structure}
\textit{It is also necessary, that the source code itself is of the best possible quality.}
\begin{itemize} \itemsep-0.5pt
 \item In order to allow the physicists an easy manipulation of the code, the programming language has been voted to python. We will use the python3 version to be up to date, being able to use the newest external packages and the annotation feature introduced in python3.
 \item We will use the guidelines for the code declared in PEP0008 and the guidelines for docstrings in declared in PEP0257.
 \item We want to make the development process easier by using the type hints declared in PEP0484. We will use mypy for static typechecking and write also our own limited typechecker for runtime typechecking.
 \item For each self written python file, there will be a unittest, covering as much as possible of the functionality of the given module. These files will be stored apart from the main source code to increase readability and reduce confusion (see folder \texttt{/test}).
 \item The code on the gihub should always be running code. Therefore Travis CI has been integrated into the project, running all the tests before committing. Only if all test where successful, a push onto the github repo is allowed. This does not include formatation checks.
\end{itemize}


\section{Related Software}
\subsection{The ``\texttt{QtLab}'' Project}
Patrick Behtke suggested the usage of the QtLab\footnote{\href{http://qtlab.sourceforge.net/}{qtlab.sourceforge.net} and \href{https://github.com/teamdiamond/measurement}{github.com/teamdiamond/measurement}}, a similar project with a focus on data acquisition/analysis and pulse generation for quantum transportation. It is written in Python following an object oriented approach. However, there seems to be no official release and the source code is not very well documented, making it difficult to understand, maintain or even get it to run. It is also limited in terms of how pulses are modelled: Each kind of pulse has to be implemented as a subclass of an abstract pulse class. There is no means to define pulses via data such as the pulse table concept in the pulsecontrol project. Additionally, it is also not possible to nest pulses or parameterize them. While this functionality could in theory be added to QtLab, we are reluctant to touch the code due to the lack of documentation. Given all that, we are unsure whether we can benefit from reusing the QtLab software.\par
However, interfaces and concepts of the QtLab may prove to be a useful reference for QC-Toolkit. Especially setting up, executing and evaluating a measurement seems to be relatively easy for the end user and could be used as an inspiration for corresponding interfaces.

% \section{Current Implementation status and planning}


% \section{Implementation Proposition}
% \label{sec:Proposition}
% During several discussions with members of the Bluhm Group (Patrick Bethke and Pascal Cerfontaine), a first implementation idea came up, how to restructure the pulsecontrol project.  
% 
% \subsection{Layers}
% The software system will be subdivided into layers of increasing levels of abstraction from bottom to top. These layers are shortly introduced in the following and their interfaces are specified in greater detail afterwards.
% \paragraph{Driver Layer} The bottom-most layer of the software located directly above the hardware drivers of the hardware manufacturers. It defines abstract interfaces for AWGs (Arbitrary Waveform Generators) and DACs (Data Acqusition Cards) and implements these for specific hardware models. These implementations will be as modular as possible and result in units interchangeable by dynamic linking. This layer offers functionality to upload and playback waveforms on single AWGs and read raw measurment data from single DACs.
% \paragraph{Hardware Abstraction Layer} Located above the Driver Layer, the HAL abstract from the concrete hardware setup. Its interface only offers functionality that operates on virtual channel which are interally mapped on the concrete hardware channels. This mapping is not exposed to higher levels. Datawise this layer also operates on waveforms and raw data.
% \paragraph{Data Abstraction Layer} This layer abstracts from raw data and provides means to define pulses on a higher level as trees of subelements. It also offers functionality to filter, transform and identify/map measured data.
% \paragraph{TimeStream Layer}
% \paragraph{Quantum Circuit Layer}
% 
% 
% \subsubsection{The Driver Layer}
% 
% \paragraph{AWG}
% \paragraph{DAC}
% 
% \subsubsection{The Hardware Abstraction Layer}
% 
% \subsubsection{The Data Abstraction Layer}
% 
% \paragraph{Pulse Configuration}
% 
% \paragraph{Measurement Configuration}
% 
% \subsubsection{The \texttt{TimeStream}-representation}
% A quantum algorithm can be modeled as quantum cirquit. In this model, each qubit has its own lifeline on which gates will eventually appear. This kind of representation lead us to the following implementation idea:
% 
% For each \texttt{Qubit}, our \texttt{Experiment} will have a \texttt{TimeStream}-Object, storing time ordered action similar to the quantum circuit. 
% This \texttt{TimeStream} object may now contain a list of \texttt{Action}s. These \texttt{Action}s could be:
% \begin{itemize} \itemsep-0.5pt
%  \item \texttt{Initialisation}s: pulse or nonpulse changes to the \texttt{Experiment}
%  \item \texttt{Execution}s: simple executions of \texttt{Pulse}s
%  \item \texttt{ConditionedLoop}s: You may pass a function and a \texttt{Pulse}, this \texttt{Pulse} will be repeated, as long as the function returns \texttt{true}.
%  \item and many more.
% \end{itemize}
% 
% To archive more flexibility, we could also allow to nest \texttt{TimeStream} objects or use them in \texttt{Action} objects and an \texttt{Action} object may also be a \texttt{TimeStream} object.
% 
% Another possibility of such an implementation is the ability to take snapshots, un- and redo actions. When we track all actions and find an adequate way to store the state of the \texttt{Experiment}, we may allow the user to save their work in mid way and continue their work afterwards.
% 
% \subsubsection{Quantum Circuit Layer and Algorithm Layer}

%\subsection{Implementation Language}
%The current software is mostly implemented using the MATLAB script language with some C(++) code for the basic hardware operations. The Bluhm Group wants to migrate away from MATLAB as the language to set up and run the experiment and favors Python at the moment.\par
%Python - and other interpreted languages with dynamic typing - are great for prototyping and writing small programs fast, which makes them ideal to quickly write a small script that sets up some pulses and executes an experiment without the need to separately compile the program after each small change.\par
%However, these languages tend to result in software that is hard to maintain when used in more complex systems. Especially the lack of static type checks requires the programmer to introduce more sanity checks for parameters and attributes. A compilation phase that is separated from execution often makes it easier to find inconsistencies and errors in the code (before the program is run). Thus, for the implementation of the core functionality of the software, a statically typed language (such as Java, C++, C\#, ...) should be used.\par
%Statically typed languages are often a bit more difficult for inexperienced users (or someone who just wants to set up his experiment). Thus, an interface of required functionality should be implemented to allow the usage from scripting languages while the implementation of these features is done in a statically typed language. Ideally, setting up an experiment and required pulses is entirely data driven in the final software and does not require the user to touch any programming language, if he does not want to.\par
%C++/C seem to provide the best option for cross-language interface definition, since nearly every interpreted language offers functionality to access C libraries. Additionally, the device drivers of the hardware used in the experiment already come as C libraries. Using these would be easiest in C++/C (this is only a very minor argument, though).

\section{Terminology}
 \begin{description}
  \item[AWG]: Arbitrary waveform generator, output device.
  \item[Pulse]: Internal representation of a tension curve.
  \item[PulseTab]: Pulse defined by some points with linear integration in between.
%   \item[ClockedPulse]: Clockewise ``hard coded'' representation of a pulse.
  \item[Experiment]: The set of Input-Data, Measurements and Documentation for each run.
  \item[Setup]: Internal representation of the links between the output-port of the AWG(s) and the QPU and QPU and the measurement tools.
  \item[Waveform]: Actual data, that will be played by the AWG. 
  \item[DAC]: Data aquisition card, measurement device.
 \end{description}

\end{document}